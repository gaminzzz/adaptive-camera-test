local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

-- Your custom animation ID
local customJumpAnim = Instance.new("Animation")
customJumpAnim.AnimationId = "rbxassetid://125791524533771"

local jumpTrack

humanoid.StateChanged:Connect(function(old, new)
	if new == Enum.HumanoidStateType.Jumping then
		if jumpTrack then
			jumpTrack:Stop()
		end
		jumpTrack = animator:LoadAnimation(customJumpAnim)
		jumpTrack.Priority = Enum.AnimationPriority.Action
		jumpTrack:Play()
	end

	-- Optional: Stop the animation when you land
	if new == Enum.HumanoidStateType.Landed or new == Enum.HumanoidStateType.Freefall then
		if jumpTrack then
			jumpTrack:Stop()
		end
	end
end)


-- gave up, chatgpt saved me.
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local character = player.Character or player.CharacterAdded:Wait()

-- üåü Aura Particles on All Parts
local function createAuraOnAllParts()
	for _, part in pairs(character:GetChildren()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			if part:FindFirstChild("AuraParticles") then continue end

			local particle = Instance.new("ParticleEmitter")
			particle.Name = "AuraParticles"
			particle.Texture = "rbxassetid://8733226116"
			particle.Brightness = 15
			particle.Color = ColorSequence.new(Color3.fromRGB(0, 255, 255)) -- Cyan
			particle.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(1, 0.8)
			}
			particle.ZOffset = 0.2
			particle.Acceleration = Vector3.new(0, 15, 0)
			particle.Speed = NumberRange.new(0, 6)
			particle.Lifetime = NumberRange.new(0.5, 1)
			particle.Rate = 5
			particle.SpreadAngle = Vector2.new(180, 180)
			particle.EmissionDirection = Enum.NormalId.Top
			particle.Shape = Enum.ParticleEmitterShape.Box
			particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
			particle.ShapePartial = 1
			particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
			particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
			particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
			particle.Size = NumberSequence.new(1.5)
			particle.Parent = part
		end
	end
end

-- üåå Primary Afterimage (Light cyan, every 3s)
local function createAfterimage1(part)
	local clone = Instance.new("Part")
	clone.Size = part.Size * 1.05
	clone.CFrame = part.CFrame
	clone.Color = Color3.fromRGB(150, 255, 255)
	clone.Transparency = 0.7
	clone.Material = Enum.Material.SmoothPlastic -- ‚úÖ Fix for transparency
	clone.CanCollide = false
	clone.Anchored = true
	clone.Name = "Afterimage1"
	clone.Shape = part.Shape == Enum.PartType.Ball and Enum.PartType.Ball or Enum.PartType.Block

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = clone

	clone.Parent = workspace

	task.spawn(function()
		local fadeTime = 1.5
		local steps = 30
		for i = 1, steps do
			clone.Transparency = 0.7 + (i / steps) * 0.3
			task.wait(fadeTime / steps)
		end
		clone:Destroy()
	end)
end

-- üåå Secondary Afterimage (Darker cyan, slower)
local function createAfterimage2(part)
	local clone = Instance.new("Part")
	clone.Size = part.Size * 1.05
	clone.CFrame = part.CFrame
	clone.Color = Color3.fromRGB(0, 100, 100)
	clone.Transparency = 0.5
	clone.Material = Enum.Material.SmoothPlastic -- ‚úÖ Also switched here
	clone.CanCollide = false
	clone.Anchored = true
	clone.Name = "Afterimage2"
	clone.Shape = part.Shape == Enum.PartType.Ball and Enum.PartType.Ball or Enum.PartType.Block

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = clone

	clone.Parent = workspace

	task.spawn(function()
		local fadeTime = 2
		local steps = 40
		for i = 1, steps do
			clone.Transparency = 0.4 + (i / steps) * 0.6
			task.wait(fadeTime / steps)
		end
		clone:Destroy()
	end)
end

-- üîÅ Start both Afterimage trails
local function startAfterimageTrails()
	-- üîÑ Primary afterimages every 3 seconds
	task.spawn(function()
		while true do
			if not character or not character:IsDescendantOf(workspace) then return end
			for _, part in pairs(character:GetChildren()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					createAfterimage1(part)
				end
			end
			task.wait(3)
		end
	end)

	-- üîÑ Secondary afterimages every 1 second
	task.spawn(function()
		while true do
			if not character or not character:IsDescendantOf(workspace) then return end
			for _, part in pairs(character:GetChildren()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					createAfterimage2(part)
				end
			end
			task.wait(1)
		end
	end)
end

-- ‚òëÔ∏è Initialize all effects
createAuraOnAllParts()
startAfterimageTrails()

-- üóëÔ∏è Removed attachBarrierToPart and calls to it
