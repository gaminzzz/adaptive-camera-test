local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- CONFIG
local moveDuration = 0.3       -- Total animation time
local teleportOffset = 2       -- Distance teleported sideways
local subtleSlideDistance = 0.3 -- Subtle pre/post slide effect
local forwardBoost = 2         -- Tiny push forward

-- ANIMATIONS
local leftAnim = Instance.new("Animation")
leftAnim.AnimationId = "rbxassetid://9443520855"

local rightAnim = Instance.new("Animation")
rightAnim.AnimationId = "rbxassetid://9443521999"

local toggleDash = false
local dashCoroutine
local currentAnimTrack

-- MOVEMENT FUNCTION
local function dash(direction)
	if not character or not humanoidRootPart then return end

	-- Stop previous animation if playing
	if currentAnimTrack then
		currentAnimTrack:Stop()
	end

	-- Play the right animation
	local animToPlay = direction == -1 and leftAnim or rightAnim
	currentAnimTrack = humanoid:LoadAnimation(animToPlay)
	currentAnimTrack:Play()

	-- Optional: quick pre-slide to fake anticipation
	local preSlide = humanoidRootPart.CFrame + humanoidRootPart.CFrame.RightVector * direction * subtleSlideDistance
	humanoidRootPart.CFrame = preSlide

	-- Wait a bit to match anticipation
	task.wait(moveDuration / 3)

	-- Teleport sideways + slight forward nudge
	humanoidRootPart.CFrame += humanoidRootPart.CFrame.RightVector * direction * teleportOffset
	humanoidRootPart.Velocity = humanoidRootPart.CFrame.LookVector * forwardBoost

	-- Optional: post-slide for trailing effect
	local postSlide = humanoidRootPart.CFrame + humanoidRootPart.CFrame.RightVector * direction * subtleSlideDistance
	humanoidRootPart.CFrame = postSlide
end

-- TOGGLE DASH LOOP
local function startTogglingDashes()
	dashCoroutine = coroutine.create(function()
		while toggleDash do
			dash(-1)
			task.wait(moveDuration)
			if not toggleDash then break end

			dash(1)
			task.wait(moveDuration)
		end
	end)
	coroutine.resume(dashCoroutine)
end

local function stopTogglingDashes()
	toggleDash = false
	if dashCoroutine and coroutine.status(dashCoroutine) == "suspended" then
		coroutine.close(dashCoroutine)
	end
	if currentAnimTrack then
		currentAnimTrack:Stop()
		currentAnimTrack = nil
	end
end

-- INPUT
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.J then
		dash(-1)
	elseif input.KeyCode == Enum.KeyCode.L then
		dash(1)
	elseif input.KeyCode == Enum.KeyCode.K then
		toggleDash = not toggleDash
		if toggleDash then
			startTogglingDashes()
		else
			stopTogglingDashes()
		end
	end
end)
