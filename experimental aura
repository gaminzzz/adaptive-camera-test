local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local character = player.Character or player.CharacterAdded:Wait()

-- üåü Aura Particles on All Parts
local function createAuraOnAllParts()
	for _, part in pairs(character:GetChildren()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			if part:FindFirstChild("AuraParticles") then continue end

			local particle = Instance.new("ParticleEmitter")
			particle.Name = "AuraParticles"
			particle.Texture = "rbxassetid://8733226116"
			particle.Brightness = 15
			particle.Color = ColorSequence.new(Color3.fromRGB(0, 255, 255)) -- Cyan
			particle.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(1, 0.8)
			}
			particle.ZOffset = 0.2
			particle.Acceleration = Vector3.new(0, 15, 0)
			particle.Speed = NumberRange.new(0, 6)
			particle.Lifetime = NumberRange.new(0.5, 1)
			particle.Rate = 10 -- üîª Reduced particle rate
			particle.SpreadAngle = Vector2.new(180, 180) -- üîÅ Wider spread
			particle.EmissionDirection = Enum.NormalId.Top
			particle.Shape = Enum.ParticleEmitterShape.Box
			particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
			particle.ShapePartial = 1
			particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
			particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
			particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
			particle.Size = NumberSequence.new(1.5) -- üîÅ Bigger emission size
			particle.Parent = part
		end
	end
end

-- üåå Afterimage Trail
local function createAfterimage(part)
	local clone = Instance.new("Part")
	clone.Size = part.Size * 1.05 -- Slightly bigger
	clone.CFrame = part.CFrame
	clone.Color = Color3.fromRGB(150, 255, 255) -- Pastel cyan
	clone.Transparency = 0.7
	clone.Material = Enum.Material.ForceField
	clone.CanCollide = false
	clone.Anchored = true
	clone.Name = "Afterimage"
	clone.Shape = part.Shape == Enum.PartType.Ball and Enum.PartType.Ball or Enum.PartType.Block

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = clone

	clone.Parent = workspace

	task.spawn(function()
		local fadeTime = 0.25
		local steps = 10
		for i = 1, steps do
			clone.Transparency = 0.7 + (i / steps) * 0.3
			task.wait(fadeTime / steps)
		end
		clone:Destroy()
	end)
end

-- üõ°Ô∏è Mesh-Based Visual Barrier
local function attachBarrierToPart(part)
	if part:FindFirstChild("BarrierVisual") then return end

	local visual = Instance.new("Part")
	visual.Name = "BarrierVisual"
	visual.Anchored = false
	visual.CanCollide = false
	visual.Massless = true
	visual.Transparency = 0.7
	visual.Color = Color3.fromRGB(0, 255, 255)
	visual.Material = Enum.Material.ForceField
	visual.Size = part.Size * 1.05
	visual.CFrame = part.CFrame
	visual.Parent = part

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = part
	weld.Part1 = visual
	weld.Parent = visual

	local mesh = Instance.new("SpecialMesh")
	mesh.Scale = Vector3.new(1.05, 1.05, 1.05)

	-- Match correct shape type
	local nameLower = part.Name:lower()
	if nameLower:find("arm") or nameLower:find("leg") then
		mesh.MeshType = Enum.MeshType.Cylinder
	elseif nameLower == "head" then
		mesh.MeshType = Enum.MeshType.Head
	else
		mesh.MeshType = Enum.MeshType.Brick
	end

	mesh.Parent = visual
end

-- üîÅ Constant afterimage loop
local function startAfterimageTrail()
	RunService.RenderStepped:Connect(function()
		if not character or not character:IsDescendantOf(workspace) then return end
		for _, part in pairs(character:GetChildren()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				createAfterimage(part)
			end
		end
	end)
end

-- ‚òëÔ∏è Initialize all effects
createAuraOnAllParts()

for _, part in pairs(character:GetChildren()) do
	if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
		attachBarrierToPart(part)
	end
end

startAfterimageTrail()
