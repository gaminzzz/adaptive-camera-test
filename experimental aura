-- gave up, chatgpt saved me.
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local character = player.Character or player.CharacterAdded:Wait()

-- üåü Aura Particles on All Parts
local function createAuraOnAllParts()
	for _, part in pairs(character:GetChildren()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			if part:FindFirstChild("AuraParticles") then continue end

			local particle = Instance.new("ParticleEmitter")
			particle.Name = "AuraParticles"
			particle.Texture = "rbxassetid://8733226116"
			particle.Brightness = 15
			particle.Color = ColorSequence.new(Color3.fromRGB(0, 255, 255)) -- Cyan
			particle.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(1, 0.8)
			}
			particle.ZOffset = 0.2
			particle.Acceleration = Vector3.new(0, 15, 0)
			particle.Speed = NumberRange.new(0, 6)
			particle.Lifetime = NumberRange.new(0.5, 1)
			particle.Rate = 5 -- üîª Lowered particle rate
			particle.SpreadAngle = Vector2.new(180, 180)
			particle.EmissionDirection = Enum.NormalId.Top
			particle.Shape = Enum.ParticleEmitterShape.Box
			particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
			particle.ShapePartial = 1
			particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
			particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
			particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
			particle.Size = NumberSequence.new(1.5)
			particle.Parent = part
		end
	end
end

-- üåå Primary Afterimage (Light cyan, frequent)
local function createAfterimage1(part)
	local clone = Instance.new("Part")
	clone.Size = part.Size * 1.05
	clone.CFrame = part.CFrame
	clone.Color = Color3.fromRGB(150, 255, 255) -- Light cyan
	clone.Transparency = 0.7
	clone.Material = Enum.Material.ForceField
	clone.CanCollide = false
	clone.Anchored = true
	clone.Name = "Afterimage1"
	clone.Shape = part.Shape == Enum.PartType.Ball and Enum.PartType.Ball or Enum.PartType.Block

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = clone

	clone.Parent = workspace

	task.spawn(function()
		local fadeTime = 1.5
		local steps = 30
		for i = 1, steps do
			clone.Transparency = 0.7 + (i / steps) * 0.3
			task.wait(fadeTime / steps)
		end
		clone:Destroy()
	end)
end

-- üåå Secondary Afterimage (Darker cyan, slower, more opaque)
local function createAfterimage2(part)
	local clone = Instance.new("Part")
	clone.Size = part.Size * 1.05
	clone.CFrame = part.CFrame
	clone.Color = Color3.fromRGB(0, 100, 100) -- Darker cyan
	clone.Transparency = 0.1 -- More opaque
	clone.Material = Enum.Material.ForceField
	clone.CanCollide = false
	clone.Anchored = true
	clone.Name = "Afterimage2"
	clone.Shape = part.Shape == Enum.PartType.Ball and Enum.PartType.Ball or Enum.PartType.Block

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = clone

	clone.Parent = workspace

	task.spawn(function()
		local fadeTime = 2
		local steps = 40
		for i = 1, steps do
			clone.Transparency = 0.4 + (i / steps) * 0.6
			task.wait(fadeTime / steps)
		end
		clone:Destroy()
	end)
end

-- üõ°Ô∏è Barrier Visuals (using real head mesh)
local function attachBarrierToPart(part)
	if part:FindFirstChild("BarrierVisual") then return end

	local visual = Instance.new("Part")
	visual.Name = "BarrierVisual"
	visual.Anchored = false
	visual.CanCollide = false
	visual.Massless = true
	visual.Transparency = 0.7
	visual.Color = Color3.fromRGB(0, 255, 255)
	visual.Material = Enum.Material.ForceField
	visual.Size = part.Size * 1.05
	visual.CFrame = part.CFrame
	visual.Parent = part

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = part
	weld.Part1 = visual
	weld.Parent = visual

	local mesh = Instance.new("SpecialMesh")
	local nameLower = part.Name:lower()

	if nameLower == "head" then
		mesh.MeshType = Enum.MeshType.FileMesh
		mesh.MeshId = "rbxassetid://134079402" -- üß† Real head mesh
		mesh.Scale = Vector3.new(1.05, 1.05, 1.05)
	elseif nameLower:find("arm") or nameLower:find("leg") then
		mesh.MeshType = Enum.MeshType.Cylinder
		mesh.Scale = Vector3.new(1.05, 1.05, 1.05)
	else
		mesh.MeshType = Enum.MeshType.Brick
		mesh.Scale = Vector3.new(1.05, 1.05, 1.05)
	end

	mesh.Parent = visual
end

-- üîÅ Start both Afterimage trails
local function startAfterimageTrails()
	-- Regular frequent trail
	RunService.RenderStepped:Connect(function()
		if not character or not character:IsDescendantOf(workspace) then return end
		for _, part in pairs(character:GetChildren()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				createAfterimage1(part)
			end
		end
	end)

	-- Slower, darker trail every 1s
	task.spawn(function()
		while true do
			if not character or not character:IsDescendantOf(workspace) then return end
			for _, part in pairs(character:GetChildren()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					createAfterimage2(part)
				end
			end
			task.wait(1)
		end
	end)
end

-- ‚òëÔ∏è Initialize all effects
createAuraOnAllParts()

for _, part in pairs(character:GetChildren()) do
	if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
		attachBarrierToPart(part)
	end
end

startAfterimageTrails()
